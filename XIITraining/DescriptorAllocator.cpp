#include "DescriptorAllocator.h"

DescriptorAllocator::DescriptorAllocator(ID3D12Device* pDevice) : 
	m_pDevice(pDevice),
	m_descriptorByteSize(pDevice->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV))
{
	// 创建一个 shader-visible 的描述符堆，用于渲染前每帧提交。
	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	desc.NodeMask = 0;
	desc.NumDescriptors = DESCRIPTOR_NUM_PER_HEAP_MAXLIMIT;
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	m_pDevice->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&m_renderHeap));
}

//D3D12_CPU_DESCRIPTOR_HANDLE DescriptorAllocator::Alloc(DescriptorType type, UINT allocSize)
//{
//	UINT heapIdx, descriptorIdx;
//
//	// 检查当前所有对应类型的堆中是否还有可用空间，有的话记录是 哪个堆（heapIdx）的 哪个描述符段（descriptorIdx）
//	if (!CheckAllocable(type, allocSize, heapIdx, descriptorIdx))
//	{
//		// 没有可用空间，创建一个新的堆
//		heapIdx = (UINT)m_heaps.size();
//		descriptorIdx = 0;
//		CreateHeap(type, allocSize);
//	}
//
//	// 返回 alloc 分配的第一个描述符的 CPU 句柄，配合 allocSize 即可让外层方法使用
//	D3D12_CPU_DESCRIPTOR_HANDLE handle = m_heaps[heapIdx].data->GetCPUDescriptorHandleForHeapStart();
//	handle.ptr += descriptorIdx * m_descriptorByteSize;
//
//	return handle;
//}

// 分配一个大小为 size 的内存块
// size: 要分配的内存块的大小
// oPageIdx: 分配到的页的下标
// oFirstIdx: 分配到的页中的第一个内存块的下标
bool DescriptorAllocator::Alloc(DescriptorType type, UINT size, UINT& oPageIdx, UINT& oFirstIdx, D3D12_CPU_DESCRIPTOR_HANDLE& oHandle)
{
	if (size > m_eachPageDataNum) return false;

	for (UINT i = 0; i < (UINT)m_pages.size(); i++)
	{
		auto& page = m_pages[i];
		if (page.type != type) continue;

		for (auto& space : page.freeIntervals)
		{
			if (space.ed - space.st + 1 >= size && space.st + size <= m_eachPageDataNum)
			{
				// 如果找到合适的空闲内存
				if (space.st + size <= space.ed)
					page.freeIntervals.insert({ space.st + size, space.ed });

				page.freeIntervals.erase(space);

				oPageIdx = i;
				oFirstIdx = space.st;

				oHandle = page.data->GetCPUDescriptorHandleForHeapStart();
				oHandle.ptr += oFirstIdx * m_descriptorByteSize;
				return true;
			}
		}
	}

	// 如果已经达到了最大页数，无法再分配
	if (m_pages.size() >= m_pageNumLimit) return false;

	// 如果没有找到合适的空闲内存，需要新分配一页
	auto& newPage = m_pages.emplace_back(m_eachPageDataNum);
	oPageIdx = (UINT)m_pages.size() - 1;
	oFirstIdx = 0;
	oHandle = newPage.data->GetCPUDescriptorHandleForHeapStart();
	return true;
}

void DescriptorAllocator::Remove(UINT pageIdx, UINT start, UINT size)
{
	auto& freeIntervals = m_pages[pageIdx].freeIntervals;

	UINT end = min(start + size - 1, m_eachPageDataNum - 1);

	AllocatorRangeInterval adjust(start, end);
	std::set<AllocatorRangeInterval> removing;
	for (auto& space : freeIntervals)
	{
		bool bCombine = false;
		if (space.st >= start && space.ed <= end)
		{
			// 如果 space 是子集，删除
			removing.insert(space);
		}
		else if (space.st <= end && start <= space.ed)
		{
			// 如果 space 是交集，合并
			removing.insert(space);
			bCombine = true;
		}
		else if (space.st < start || space.ed > end)
		{
			// 如果 space 是父集，什么都不做
		}
		else bCombine = true;

		if (bCombine)
		{
			adjust.st = min(adjust.st, space.st);
			adjust.ed = max(adjust.ed, space.ed);
		}
	}

	for (auto& space : removing) freeIntervals.erase(space);

	// 如果 adjust 和 m_freeInterval 形成连号，需要再合并一次。
	removing.clear();
	for (auto& space : freeIntervals)
	{
		if (space.st == adjust.ed + 1)
		{
			adjust.ed = space.ed;
			removing.insert(space);
		}
		else if (space.ed == adjust.st - 1)
		{
			adjust.st = space.st;
			removing.insert(space);
		}
	}

	freeIntervals.insert(adjust);
	for (auto& space : removing) freeIntervals.erase(space);
}

UINT DescriptorAllocator::AppendToRenderHeap(const size_t* cpuHandles, const size_t cpuHandlesSize)
{
	UINT firstOffsetIndex = m_currentOffset;

	for (size_t i = 0; i < cpuHandlesSize; i++)
	{
		D3D12_CPU_DESCRIPTOR_HANDLE srcHandle;
		srcHandle.ptr = cpuHandles[i];

		// 计算新的 ring buffer 偏移量
		UINT heapOffset = m_currentOffset * m_descriptorByteSize;
		D3D12_CPU_DESCRIPTOR_HANDLE destHandle = m_renderHeap->GetCPUDescriptorHandleForHeapStart();
		destHandle.ptr += heapOffset;

		// 拷贝描述符
		m_pDevice->CopyDescriptorsSimple(1, destHandle, srcHandle, D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

		// 更新偏移量
		m_currentOffset = (m_currentOffset + 1) % DESCRIPTOR_NUM_PER_HEAP_MAXLIMIT;
	}

	return firstOffsetIndex;
}
